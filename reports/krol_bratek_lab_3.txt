import numpy as np
from sklearn.utils.extmath import randomized_svd


class CompressTree():
    def __init__(self, matrix, t_min, t_max, s_min, s_max):
        self.matrix = matrix
        self.t_min = t_min
        self.t_max = t_max
        self.s_min = s_min
        self.s_max = s_max
        self.rank = None
        self.U = None
        self.S = None
        self.V = None
        self.is_leaf = False
        self.zeros = False
        self.children = []


    def is_admissible(self, S, r, epsilon):
        return self.t_min + r == self.t_max or S[r] <= epsilon

    def set_leaf(self, U, S, V):
        self.is_leaf = True
        self.U = U
        self.S = S
        self.V = V

    def compress(self, r, epsilon):
        matrix_block = self.matrix[self.t_min:self.t_max, self.s_min:self.s_max]

        if np.sum(matrix_block) == 0:
            self.rank = 0
            self.is_leaf = True
            self.zeros = True
            return self

        U, Sigma, V = randomized_svd(matrix_block,n_components=r+1, random_state=0)
        if self.is_admissible(Sigma, r, epsilon):
            self.rank = r
            self.set_leaf(U[:, :r], Sigma[:r], V[:r, :])
            return self
        else:
            self.children = []
            new_t_max = (self.t_min + self.t_max) // 2
            new_s_max = (self.s_min + self.s_max) // 2
            row_splits = [(self.t_min, new_t_max), (new_t_max, self.t_max)]
            col_splits = [(self.s_min, new_s_max), (new_s_max, self.s_max)]

            for t_min, t_max in row_splits:
                for s_min, s_max in col_splits:
                    child = CompressTree(self.matrix, t_min, t_max, s_min, s_max)
                    self.children.append(child)

            for child in self.children:
                child.compress(r, epsilon)

    def decompress(self):
        if self.is_leaf:
            if self.zeros:
                return np.zeros((self.t_max - self.t_min, self.s_max - self.s_min))
            return (self.U @ np.diag(self.S) @ self.V).reshape(self.t_max - self.t_min, self.s_max - self.s_min)


        nrows = self.t_max - self.t_min
        ncols = self.s_max - self.s_min
        decompressed_matrix = np.zeros((nrows, ncols))

        half_row = (self.t_max + self.t_min) // 2
        half_col = (self.s_max + self.s_min) // 2
        for i, child in enumerate(self.children):
            if i == 0:
                decompressed_matrix[:half_row - self.t_min, :half_col - self.s_min] = child.decompress()
            elif i == 1:
                decompressed_matrix[:half_row - self.t_min, half_col - self.s_min:] = child.decompress()
            elif i == 2:
                decompressed_matrix[half_row - self.t_min:, :half_col - self.s_min] = child.decompress()
            elif i == 3:
                decompressed_matrix[half_row - self.t_min:, half_col - self.s_min:] = child.decompress()

        return decompressed_matrix


def test_compression(matrix, r=2, eps=1e-5, tolerance=1e-3):
    matrix_tree = CompressTree(matrix, 0, matrix.shape[0], 0, matrix.shape[1])
    matrix_tree.compress(r, eps)

    decompressed_matrix = matrix_tree.decompress()

    print("Oryginalna macierz:")
    print(matrix)
    print("\nZdekompresowana macierz:")
    print(decompressed_matrix)

    difference = np.linalg.norm(matrix - decompressed_matrix)
    print("\nNorma różnicy między oryginalną a zdekompresowaną macierzą:", difference)

    if difference < tolerance:
        print("Zdekompresowana macierz jest bliska oryginalnej.")
    else:
        print("Zdekompresowana macierz różni się od oryginalnej.")



import numpy as np
import matplotlib.pyplot as plt


def reconstruct_block(node):
    if node.is_leaf:
        if node.zeros:
            return np.zeros((node.t_max - node.t_min, node.s_max - node.s_min))
        else:
            return node.U @ np.diag(node.S) @ node.V
    else:
        raise ValueError("Node is not a leaf.")


class CompressTreeBitmapVisualizer:
    def __init__(self, compress_tree):
        self.compress_tree = compress_tree

    def reconstruct_matrix(self):
        matrix = np.zeros_like(self.compress_tree.matrix)
        stack = [self.compress_tree]

        while stack:
            node = stack.pop()
            if node.is_leaf:
                block = reconstruct_block(node)
                matrix[node.t_min:node.t_max, node.s_min:node.s_max] = block
            else:
                stack.extend(node.children)

        return matrix

    def draw_bitmap(self):
        matrix = self.reconstruct_matrix()
        return matrix


class CompressTreeStructureVisualizer:
    def __init__(self, compress_tree):
        self.compress_tree = compress_tree

    def visualize_tree_structure(self):
        rows, cols = self.compress_tree.matrix.shape
        structure = np.ones((rows, cols))

        def mark_blocks(node):
            if node.is_leaf:
                if not node.zeros:
                    structure[node.t_min:node.t_min + node.rank,
                              node.s_min:node.s_max] = 0

                    structure[node.t_min :node.t_max,
                              node.s_min:node.s_min + node.rank] = 0
            else:

                for child in node.children:
                    mark_blocks(child)

        mark_blocks(self.compress_tree)

        plt.figure(figsize=(10, 10))
        plt.imshow(structure, cmap="gray", interpolation="nearest")
        plt.title("Tree Structure Visualization (U, S, V blocks)")
        plt.axis("off")
        plt.show()


def main():
    image_path = "images/city.jpg"
    crop_box = (0, 0, 512, 512)
    visualize_compressed_image(image_path, crop_box)


def visualize_compressed_image(image_path, crop_box, r=4, sigma_n=512):
    image = Image.open(image_path)
    image = image.crop(crop_box)
    image = image.convert("RGB")
    # image.show()
    bitmap = np.array(image)
    red_channel = bitmap[:, :, 0]
    green_channel = bitmap[:, :, 1]
    blue_channel = bitmap[:, :, 2]

    plt.figure(figsize=(12, 4))
    plt.subplot(1, 3, 1)
    plt.imshow(red_channel, cmap="Reds")
    plt.title("Red Channel")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(green_channel, cmap="Greens")
    plt.title("Green Channel")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(blue_channel, cmap="Blues")
    plt.title("Blue Channel")
    plt.axis("off")

    plt.show()

    _, R_sigma, _ = randomized_svd(red_channel, n_components=sigma_n, random_state=0)
    _, G_sigma, _ = randomized_svd(red_channel, n_components=sigma_n, random_state=0)
    _, B_sigma, _ = randomized_svd(red_channel, n_components=sigma_n, random_state=0)

    print(R_sigma, G_sigma, B_sigma)
    x = np.arange(0, sigma_n)
    plt.title("Singular values for RGB channels")
    plt.plot(x, R_sigma, label="Red Channel", color="red")
    plt.plot(x, G_sigma, label="Green Channel", color="green")
    plt.plot(x, B_sigma, label="Blue Channel", color="blue")
    plt.xlabel('i')
    plt.ylabel('y')
    plt.yscale('log')
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),
               fancybox=True, shadow=True, ncol=1)
    plt.grid()
    plt.show()
    R_sigma=R_sigma[-1]
    G_sigma=G_sigma[-1]
    B_sigma=B_sigma[-1]
    red_tree = CompressTree(red_channel, 0, red_channel.shape[0], 0, red_channel.shape[1])
    red_tree.compress(r, R_sigma)

    green_tree = CompressTree(green_channel, 0, green_channel.shape[0], 0, green_channel.shape[1])
    green_tree.compress(r, G_sigma)

    blue_tree = CompressTree(blue_channel, 0, blue_channel.shape[0], 0, blue_channel.shape[1])
    blue_tree.compress(r, B_sigma)

    visualizer_red = CompressTreeStructureVisualizer(red_tree)
    visualizer_green = CompressTreeStructureVisualizer(green_tree)
    visualizer_blue = CompressTreeStructureVisualizer(blue_tree)

    visualizer_red.visualize_tree_structure()
    visualizer_green.visualize_tree_structure()
    visualizer_blue.visualize_tree_structure()

    visualizer_red_ = CompressTreeBitmapVisualizer(red_tree)
    visualizer_green_ = CompressTreeBitmapVisualizer(green_tree)
    visualizer_blue_ = CompressTreeBitmapVisualizer(blue_tree)

    red_compressed = visualizer_red_.draw_bitmap()
    green_compressed = visualizer_green_.draw_bitmap()
    blue_compressed = visualizer_blue_.draw_bitmap()

    plt.figure(figsize=(12, 4))
    plt.subplot(1, 3, 1)
    plt.imshow(red_compressed, cmap="Reds")
    plt.title("Red Channel")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(green_compressed, cmap="Greens")
    plt.title("Green Channel")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(blue_compressed, cmap="Blues")
    plt.title("Blue Channel")
    plt.axis("off")

    plt.show()

    reconstructed_bitmap = np.stack([red_compressed, green_compressed, blue_compressed], axis=-1)

    reconstructed_image = Image.fromarray(reconstructed_bitmap)
    reconstructed_image.show()