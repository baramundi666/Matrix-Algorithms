class Calculator:
    def __init__(self):
        self.total_count = 0
        self.add_count = 0
        self.subtract_count = 0
        self.negate_count = 0
        self.multiply_count = 0

    def reset_counters(self):
        self.total_count = 0
        self.add_count = 0
        self.subtract_count = 0
        self.negate_count = 0
        self.multiply_count = 0

    def add(self, matrix_1, matrix_2):
        n = len(matrix_1)
        m = len(matrix_1[0])
        matrix_3 = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                # atomic addition
                self.total_count += 1
                self.add_count += 1
                matrix_3[i][j] = matrix_1[i][j] + matrix_2[i][j]
        return matrix_3

    def subtract(self, matrix_1, matrix_2):
        n = len(matrix_1)
        m = len(matrix_1[0])
        matrix_3 = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                # atomic subtraction
                self.total_count += 1
                self.subtract_count += 1
                matrix_3[i][j] = matrix_1[i][j] - matrix_2[i][j]
        return matrix_3

    def negate(self, matrix):
        n = len(matrix)
        m = len(matrix[0])
        matrix_ = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                # atomic negation
                self.total_count += 1
                self.negate_count += 1
                matrix_[i][j] = -matrix[i][j]
        return matrix_

    def multiply_one_by_one_matrices(self, matrix_1, matrix_2):
        # atomic multiplication
        self.total_count += 1
        self.multiply_count += 1
        matrix_3 = [[matrix_1[0][0] * matrix_2[0][0]]]
        return matrix_3

    def split_into_block_matrices(self, matrix):
        n = len(matrix)
        matrix_11 = [[0 for _ in range(n // 2)] for _ in range(n // 2)]
        matrix_12 = [[0 for _ in range(n // 2)] for _ in range(n // 2)]
        matrix_21 = [[0 for _ in range(n // 2)] for _ in range(n // 2)]
        matrix_22 = [[0 for _ in range(n // 2)] for _ in range(n // 2)]
        for i in range(n):
            for j in range(n):
                if i < n // 2 and j < n // 2:
                    matrix_11[i][j] = matrix[i][j]
                elif i < n // 2 and j >= n // 2:
                    matrix_12[i][j - n // 2] = matrix[i][j]
                elif i >= n // 2 and j < n // 2:
                    matrix_21[i - n // 2][j] = matrix[i][j]
                elif i >= n // 2 and j >= n // 2:
                    matrix_22[i - n // 2][j - n // 2] = matrix[i][j]
        return matrix_11, matrix_12, matrix_21, matrix_22

    def connect_block_matrices(self, matrix_11, matrix_12, matrix_21, matrix_22):
        n = len(matrix_11)
        matrix = [[0 for _ in range(2 * n)] for _ in range(2 * n)]
        for i in range(2 * n):
            for j in range(2 * n):
                if i < n and j < n:
                    matrix[i][j] = matrix_11[i][j]
                elif i < n and j >= n:
                    matrix[i][j] = matrix_12[i][j - n]
                elif i >= n and j < n:
                    matrix[i][j] = matrix_21[i - n][j]
                elif i >= n and j >= n:
                    matrix[i][j] = matrix_22[i - n][j - n]
        return matrix

    def split_into_block_matrices_dynamic_peeling(self, matrix):
        n = len(matrix)
        matrix_11 = [[0 for _ in range(n-1)] for _ in range(n-1)]
        matrix_12 = [[0 for _ in range(1)] for _ in range(n-1)]
        matrix_21 = [[0 for _ in range(n-1)] for _ in range(1)]
        matrix_22 = [[0 for _ in range(1)] for _ in range(1)]
        for i in range(n):
            for j in range(n):
                if i < n-1 and j < n-1:
                    matrix_11[i][j] = matrix[i][j]
                elif i < n-1 and j >= n-1:
                    matrix_12[i][j - n + 1] = matrix[i][j]
                elif i >= n-1 and j < n-1:
                    matrix_21[i - n + 1][j] = matrix[i][j]
                elif i >= n-1 and j >= n-1:
                    matrix_22[i - n + 1][j - n + 1] = matrix[i][j]
        return matrix_11, matrix_12, matrix_21, matrix_22

    def connect_block_matrices_dynamic_peeling(self, matrix_11, matrix_12, matrix_21, matrix_22):
        n = len(matrix_11)
        matrix = [[0 for _ in range(n+1)] for _ in range(n+1)]
        for i in range(n+1):
            for j in range(n+1):
                if i < n and j < n:
                    matrix[i][j] = matrix_11[i][j]
                elif i < n and j >= n:
                    matrix[i][j] = matrix_12[i][j - n]
                elif i >= n and j < n:
                    matrix[i][j] = matrix_21[i - n][j]
                elif i >= n and j >= n:
                    matrix[i][j] = matrix_22[i - n][j - n]
        return matrix


    def standard_matrix_multiplication(self, matrix_1, matrix_2):
        assert len(matrix_1[0]) == len(matrix_2), "Wrong shapes"
        n = len(matrix_1)
        k = len(matrix_1[0])
        m = len(matrix_2[0])
        matrix = [[0 for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                matrix[i][j] = sum(matrix_1[i][s] * matrix_2[s][j] for s in range(k))
        self.add_count += n * (k-1) * m
        self.multiply_count += n * k * m

        return matrix

    def crop_matrix_to_shape(self, matrix, shape):
        matrix_ = [[matrix[i][j] for j in range(shape[1])] for i in range(shape[0])]
        return matrix_

    def expand_matrix_to_shape(self, matrix, shape):
        n = len(matrix)
        m = len(matrix[0])
        matrix_ = [[0 for _ in range(shape[1])] for _ in range(shape[0])]
        for i in range(shape[0]):
            for j in range(shape[1]):
                if i < n and j < m:
                    matrix_[i][j] = matrix[i][j]
                else:
                    matrix_[i][j] = 0

        return matrix_




class BinetAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()
        self.matrix_3 = None

    def __binet(self, A, B):
        n = len(A)
        if n == 1:
            return self.calculator.standard_matrix_multiplication(A, B)
        if n % 2 == 1:
            A11, A12, A21, A22 = self.calculator.split_into_block_matrices_dynamic_peeling(A)
            B11, B12, B21, B22 = self.calculator.split_into_block_matrices_dynamic_peeling(B)

            C11 = self.calculator.add(self.__binet(A11, B11), self.calculator.standard_matrix_multiplication(A12, B21))
            C12 = self.calculator.add(self.calculator.standard_matrix_multiplication(A11, B12), self.calculator.standard_matrix_multiplication(A12, B22))
            C21 = self.calculator.add(self.calculator.standard_matrix_multiplication(A21, B11), self.calculator.standard_matrix_multiplication(A22, B21))
            C22 = self.calculator.add(self.calculator.standard_matrix_multiplication(A21, B12), self.calculator.standard_matrix_multiplication(A22, B22))

            return self.calculator.connect_block_matrices_dynamic_peeling(C11, C12, C21, C22)
        else:
            A11, A12, A21, A22 = self.calculator.split_into_block_matrices(A)
            B11, B12, B21, B22 = self.calculator.split_into_block_matrices(B)

            C11 = self.calculator.add(self.__binet(A11, B11), self.__binet(A12, B21))
            C12 = self.calculator.add(self.__binet(A11, B12), self.__binet(A12, B22))
            C21 = self.calculator.add(self.__binet(A21, B11), self.__binet(A22, B21))
            C22 = self.calculator.add(self.__binet(A21, B12), self.__binet(A22, B22))

            return self.calculator.connect_block_matrices(C11, C12, C21, C22)

    def run(self, A, B):
        C = self.__binet(A, B)
        self.matrix_3 = C



class StrassenAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()
        self.matrix_3 = None

    def run(self, matrix_1, matrix_2):
        """
        matrix_1, matrix_2 - square matrices with size 2^n x 2^n
        """
        n = len(matrix_1)
        n_ = 2 ** math.ceil(math.log(n, 2))
        matrix_1 = self.calculator.expand_matrix_to_shape(matrix_1, (n_, n_))
        matrix_2 = self.calculator.expand_matrix_to_shape(matrix_2, (n_, n_))
        matrix_3 = self.__rec(matrix_1, matrix_2)
        self.matrix_3 = self.calculator.crop_matrix_to_shape(matrix_3, (n, n))


    def __rec(self, matrix_1, matrix_2):
        if len(matrix_1) == 1:
            return self.calculator.multiply_one_by_one_matrices(matrix_1, matrix_2)

        matrix_1_11, matrix_1_12, matrix_1_21, matrix_1_22 = self.calculator.split_into_block_matrices(matrix_1)
        matrix_2_11, matrix_2_12, matrix_2_21, matrix_2_22 = self.calculator.split_into_block_matrices(matrix_2)

        p_1 = self.__rec(self.calculator.add(matrix_1_11, matrix_1_22), self.calculator.add(matrix_2_11, matrix_2_22))
        p_2 = self.__rec(self.calculator.add(matrix_1_21, matrix_1_22), matrix_2_11)
        p_3 = self.__rec(matrix_1_11, self.calculator.subtract(matrix_2_12, matrix_2_22))
        p_4 = self.__rec(matrix_1_22, self.calculator.subtract(matrix_2_21, matrix_2_11))
        p_5 = self.__rec(self.calculator.add(matrix_1_11, matrix_1_12), matrix_2_22)
        p_6 = self.__rec(self.calculator.subtract(matrix_1_21, matrix_1_11), self.calculator.add(matrix_2_11, matrix_2_12))
        p_7 = self.__rec(self.calculator.subtract(matrix_1_12, matrix_1_22), self.calculator.add(matrix_2_21, matrix_2_22))

        matrix_3_11 = self.calculator.add(self.calculator.subtract(self.calculator.add(p_1, p_4), p_5), p_7)
        matrix_3_12 = self.calculator.add(p_3, p_5)
        matrix_3_21 = self.calculator.add(p_2, p_4)
        matrix_3_22 = self.calculator.add(self.calculator.add(self.calculator.subtract(p_1, p_2), p_3), p_6)

        matrix_3 = self.calculator.connect_block_matrices(matrix_3_11, matrix_3_12, matrix_3_21, matrix_3_22)
        return matrix_3




class Matrix:
    def __init__(self, data, calculator, multiplication):
        self.data = copy.deepcopy(data)
        self.calculator = calculator
        self.multiplication = multiplication
        self.shape = (len(data), len(data[0]))

    def __getitem__(self, idx):
        i, j = idx
        i -= 1
        j -= 1
        return self.data[i][j]

    def __setitem__(self, idx, item):
        i, j = idx
        i -= 1
        j -= 1
        self.data[i][j] = item

    def __neg__(self):
        return Matrix(self.calculator.negate(self.data), self.calculator, multiplication=self.multiplication)

    def __add__(self, other):
        return Matrix(self.calculator.add(self.data, other.data), self.calculator, multiplication=self.multiplication)

    def __sub__(self, other):
        return Matrix(self.calculator.subtract(self.data, other.data), self.calculator, multiplication=self.multiplication)

    def __matmul__(self, other):
        assert self.shape[1] == other.shape[0], "Wrong shape for multiplication"
        return self.multiplication(self, other)

    def __mul__(self, other):
        return self.__matmul__(other)

    @classmethod
    def empty(cls, n: int, m: int, calculator, multiplication):
        data = [[None for _ in range(m)] for _ in range(n)]
        return cls(data, calculator, multiplication=multiplication)

    @classmethod
    def in_place(cls, data, calculator, multiplication):
        retval = Matrix([[]], calculator, multiplication=multiplication)
        retval.data = data
        retval.shape = (len(data), len(data[0]))
        return retval




class AIAlgorithm(BaseAlgorithm):
    def __init__(self):
        super().__init__()

    @staticmethod
    def ai_compute_h(a, b):
        h = [None] * 77
        h[1] = (a[3, 2]) * (-b[2, 1] - b[2, 5] - b[3, 1])
        h[2] = (a[2, 2] + a[2, 5] - a[3, 5]) * (-b[2, 5] - b[5, 1])
        h[3] = (-a[3, 1] - a[4, 1] + a[4, 2]) * (-b[1, 1] + b[2, 5])
        h[4] = (a[1, 2] + a[1, 4] + a[3, 4]) * (-b[2, 5] - b[4, 1])
        h[5] = (a[1, 5] + a[2, 2] + a[2, 5]) * (-b[2, 4] + b[5, 1])
        h[6] = (-a[2, 2] - a[2, 5] - a[4, 5]) * (b[2, 3] + b[5, 1])
        h[7] = (-a[1, 1] + a[4, 1] - a[4, 2]) * (b[1, 1] + b[2, 4])
        h[8] = (a[3, 2] - a[3, 3] - a[4, 3]) * (-b[2, 3] + b[3, 1])
        h[9] = (-a[1, 2] - a[1, 4] + a[4, 4]) * (b[2, 3] + b[4, 1])
        h[10] = (a[2, 2] + a[2, 5]) * (b[5, 1])
        h[11] = (-a[2, 1] - a[4, 1] + a[4, 2]) * (-b[1, 1] + b[2, 2])
        h[12] = (a[4, 1] - a[4, 2]) * (b[1, 1])
        h[13] = (a[1, 2] + a[1, 4] + a[2, 4]) * (b[2, 2] + b[4, 1])
        h[14] = (a[1, 3] - a[3, 2] + a[3, 3]) * (b[2, 4] + b[3, 1])
        h[15] = (-a[1, 2] - a[1, 4]) * (b[4, 1])
        h[16] = (-a[3, 2] + a[3, 3]) * (b[3, 1])
        h[17] = (a[1, 2] + a[1, 4] - a[2, 1] + a[2, 2] - a[2, 3] + a[2, 4] - a[3, 2] + a[3, 3] - a[4, 1] + a[4, 2]) * (
            b[2, 2])
        h[18] = (a[2, 1]) * (b[1, 1] + b[1, 2] + b[5, 2])
        h[19] = (-a[2, 3]) * (b[3, 1] + b[3, 2] + b[5, 2])
        h[20] = (-a[1, 5] + a[2, 1] + a[2, 3] - a[2, 5]) * (-b[1, 1] - b[1, 2] + b[1, 4] - b[5, 2])
        h[21] = (a[2, 1] + a[2, 3] - a[2, 5]) * (b[5, 2])
        h[22] = (a[1, 3] - a[1, 4] - a[2, 4]) * (b[1, 1] + b[1, 2] - b[1, 4] - b[3, 1] - b[3, 2] + b[3, 4] + b[4, 4])
        h[23] = (a[1, 3]) * (-b[3, 1] + b[3, 4] + b[4, 4])
        h[24] = (a[1, 5]) * (-b[4, 4] - b[5, 1] + b[5, 4])
        h[25] = (-a[1, 1]) * (b[1, 1] - b[1, 4])
        h[26] = (-a[1, 3] + a[1, 4] + a[1, 5]) * (b[4, 4])
        h[27] = (a[1, 3] - a[3, 1] + a[3, 3]) * (b[1, 1] - b[1, 4] + b[1, 5] + b[3, 5])
        h[28] = (-a[3, 4]) * (-b[3, 5] - b[4, 1] - b[4, 5])
        h[29] = (a[3, 1]) * (b[1, 1] + b[1, 5] + b[3, 5])
        h[30] = (a[3, 1] - a[3, 3] + a[3, 4]) * (b[3, 5])
        h[31] = (-a[1, 4] - a[1, 5] - a[3, 4]) * (-b[4, 4] - b[5, 1] + b[5, 4] - b[5, 5])
        h[32] = (a[2, 1] + a[4, 1] + a[4, 4]) * (b[1, 3] - b[4, 1] - b[4, 2] - b[4, 3])
        h[33] = (a[4, 3]) * (-b[3, 1] - b[3, 3])
        h[34] = (a[4, 4]) * (-b[1, 3] + b[4, 1] + b[4, 3])
        h[35] = (-a[4, 5]) * (b[1, 3] + b[5, 1] + b[5, 3])
        h[36] = (a[2, 3] - a[2, 5] - a[4, 5]) * (b[3, 1] + b[3, 2] + b[3, 3] + b[5, 2])
        h[37] = (-a[4, 1] - a[4, 4] + a[4, 5]) * (b[1, 3])
        h[38] = (-a[2, 3] - a[3, 1] + a[3, 3] - a[3, 4]) * (b[3, 5] + b[4, 1] + b[4, 2] + b[4, 5])
        h[39] = (-a[3, 1] - a[4, 1] - a[4, 4] + a[4, 5]) * (b[1, 3] + b[5, 1] + b[5, 3] + b[5, 5])
        h[40] = (-a[1, 3] + a[1, 4] + a[1, 5] - a[4, 4]) * (-b[3, 1] - b[3, 3] + b[3, 4] + b[4, 4])
        h[41] = (-a[1, 1] + a[4, 1] - a[4, 5]) * (b[1, 3] + b[3, 1] + b[3, 3] - b[3, 4] + b[5, 1] + b[5, 3] - b[5, 4])
        h[42] = (-a[2, 1] + a[2, 5] - a[3, 5]) * (-b[1, 1] - b[1, 2] - b[1, 5] + b[4, 1] + b[4, 2] + b[4, 5] - b[5, 2])
        h[43] = (a[2, 4]) * (b[4, 1] + b[4, 2])
        h[44] = (a[2, 3] + a[3, 2] - a[3, 3]) * (b[2, 2] - b[3, 1])
        h[45] = (-a[3, 3] + a[3, 4] - a[4, 3]) * (b[3, 5] + b[4, 1] + b[4, 3] + b[4, 5] + b[5, 1] + b[5, 3] + b[5, 5])
        h[46] = (-a[3, 5]) * (-b[5, 1] - b[5, 5])
        h[47] = (a[2, 1] - a[2, 5] - a[3, 1] + a[3, 5]) * (b[1, 1] + b[1, 2] + b[1, 5] - b[4, 1] - b[4, 2] - b[4, 5])
        h[48] = (-a[2, 3] + a[3, 3]) * (b[2, 2] + b[3, 2] + b[3, 5] + b[4, 1] + b[4, 2] + b[4, 5])
        h[49] = (-a[1, 1] - a[1, 3] + a[1, 4] + a[1, 5] - a[2, 1] - a[2, 3] + a[2, 4] + a[2, 5]) * (
                -b[1, 1] - b[1, 2] + b[1, 4])
        h[50] = (-a[1, 4] - a[2, 4]) * (b[2, 2] - b[3, 1] - b[3, 2] + b[3, 4] - b[4, 2] + b[4, 4])
        h[51] = (a[2, 2]) * (b[2, 1] + b[2, 2] - b[5, 1])
        h[52] = (a[4, 2]) * (b[1, 1] + b[2, 1] + b[2, 3])
        h[53] = (-a[1, 2]) * (-b[2, 1] + b[2, 4] + b[4, 1])
        h[54] = (a[1, 2] + a[1, 4] - a[2, 2] - a[2, 5] - a[3, 2] + a[3, 3] - a[4, 2] + a[4, 3] - a[4, 4] - a[4, 5]) * (
            b[2, 3])
        h[55] = (a[1, 4] - a[4, 4]) * (-b[2, 3] + b[3, 1] + b[3, 3] - b[3, 4] + b[4, 3] - b[4, 4])
        h[56] = (a[1, 1] - a[1, 5] - a[4, 1] + a[4, 5]) * (b[3, 1] + b[3, 3] - b[3, 4] + b[5, 1] + b[5, 3] - b[5, 4])
        h[57] = (-a[3, 1] - a[4, 1]) * (-b[1, 3] - b[1, 5] - b[2, 5] - b[5, 1] - b[5, 3] - b[5, 5])
        h[58] = (-a[1, 4] - a[1, 5] - a[3, 4] - a[3, 5]) * (-b[5, 1] + b[5, 4] - b[5, 5])
        h[59] = (-a[3, 3] + a[3, 4] - a[4, 3] + a[4, 4]) * (b[4, 1] + b[4, 3] + b[4, 5] + b[5, 1] + b[5, 3] + b[5, 5])
        h[60] = (a[2, 5] + a[4, 5]) * (b[2, 3] - b[3, 1] - b[3, 2] - b[3, 3] - b[5, 2] - b[5, 3])
        h[61] = (a[1, 4] + a[3, 4]) * (
                b[1, 1] - b[1, 4] + b[1, 5] - b[2, 5] - b[4, 4] + b[4, 5] - b[5, 1] + b[5, 4] - b[5, 5])
        h[62] = (a[2, 1] + a[4, 1]) * (b[1, 2] + b[1, 3] + b[2, 2] - b[4, 1] - b[4, 2] - b[4, 3])
        h[63] = (-a[3, 3] - a[4, 3]) * (-b[2, 3] - b[3, 3] - b[3, 5] - b[4, 1] - b[4, 3] - b[4, 5])
        h[64] = (a[1, 1] - a[1, 3] - a[1, 4] + a[3, 1] - a[3, 3] - a[3, 4]) * (b[1, 1] - b[1, 4] + b[1, 5])
        h[65] = (-a[1, 1] + a[4, 1]) * (-b[1, 3] + b[1, 4] + b[2, 4] - b[5, 1] - b[5, 3] + b[5, 4])
        h[66] = (a[1, 1] - a[1, 2] + a[1, 3] - a[1, 5] - a[2, 2] - a[2, 5] - a[3, 2] + a[3, 3] - a[4, 1] + a[4, 2]) * (
            b[2, 4])
        h[67] = (a[2, 5] - a[3, 5]) * (
                b[1, 1] + b[1, 2] + b[1, 5] - b[2, 5] - b[4, 1] - b[4, 2] - b[4, 5] + b[5, 2] + b[5, 5])
        h[68] = (a[1, 1] + a[1, 3] - a[1, 4] - a[1, 5] - a[4, 1] - a[4, 3] + a[4, 4] + a[4, 5]) * (
                -b[3, 1] - b[3, 3] + b[3, 4])
        h[69] = (-a[1, 3] + a[1, 4] - a[2, 3] + a[2, 4]) * (-b[2, 4] - b[3, 1] - b[3, 2] + b[3, 4] - b[5, 2] + b[5, 4])
        h[70] = (a[2, 3] - a[2, 5] + a[4, 3] - a[4, 5]) * (-b[3, 1] - b[3, 2] - b[3, 3])
        h[71] = (-a[3, 1] + a[3, 3] - a[3, 4] + a[3, 5] - a[4, 1] + a[4, 3] - a[4, 4] + a[4, 5]) * (
                -b[5, 1] - b[5, 3] - b[5, 5])
        h[72] = (-a[2, 1] - a[2, 4] - a[4, 1] - a[4, 4]) * (b[4, 1] + b[4, 2] + b[4, 3])
        h[73] = (a[1, 3] - a[1, 4] - a[1, 5] + a[2, 3] - a[2, 4] - a[2, 5]) * (
                b[1, 1] + b[1, 2] - b[1, 4] + b[2, 4] + b[5, 2] - b[5, 4])
        h[74] = (a[2, 1] - a[2, 3] + a[2, 4] - a[3, 1] + a[3, 3] - a[3, 4]) * (b[4, 1] + b[4, 2] + b[4, 5])
        h[75] = -(a[1, 2] + a[1, 4] - a[2, 2] - a[2, 5] - a[3, 1] + a[3, 2] + a[3, 4] + a[3, 5] - a[4, 1] + a[4, 2]) * (
            b[2, 5])
        h[76] = (a[1, 3] + a[3, 3]) * (-b[1, 1] + b[1, 4] - b[1, 5] + b[2, 4] + b[3, 4] - b[3, 5])

        return h

    def ai_compute_c(self, h, multiplication):
        c = Matrix.empty(4, 5, self.calculator, multiplication=multiplication)

        c[1, 1] = -h[10] + h[12] + h[14] - h[15] - h[16] + h[53] + h[5] - h[66] - h[7]
        c[2, 1] = h[10] + h[11] - h[12] + h[13] + h[15] + h[16] - h[17] - h[44] + h[51]
        c[3, 1] = h[10] - h[12] + h[15] + h[16] - h[1] + h[2] + h[3] - h[4] + h[75]
        c[4, 1] = -h[10] + h[12] - h[15] - h[16] + h[52] + h[54] - h[6] - h[8] + h[9]
        c[1, 2] = h[13] + h[15] + h[20] + h[21] - h[22] + h[23] + h[25] - h[43] + h[49] + h[50]
        c[2, 2] = -h[11] + h[12] - h[13] - h[15] - h[16] + h[17] + h[18] - h[19] - h[21] + h[43] + h[44]
        c[3, 2] = -h[16] - h[19] - h[21] - h[28] - h[29] - h[38] + h[42] + h[44] - h[47] + h[48]
        c[4, 2] = h[11] - h[12] - h[18] + h[21] - h[32] + h[33] - h[34] - h[36] + h[62] - h[70]
        c[1, 3] = h[15] + h[23] + h[24] + h[34] - h[37] + h[40] - h[41] + h[55] - h[56] - h[9]
        c[2, 3] = -h[10] + h[19] + h[32] + h[35] + h[36] + h[37] - h[43] - h[60] - h[6] - h[72]
        c[3, 3] = -h[16] - h[28] + h[33] + h[37] - h[39] + h[45] - h[46] + h[63] - h[71] - h[8]
        c[4, 3] = h[10] + h[15] + h[16] - h[33] + h[34] - h[35] - h[37] - h[54] + h[6] + h[8] - h[9]
        c[1, 4] = -h[10] + h[12] + h[14] - h[16] + h[23] + h[24] + h[25] + h[26] + h[5] - h[66] - h[7]
        c[2, 4] = h[10] + h[18] - h[19] + h[20] - h[22] - h[24] - h[26] - h[5] - h[69] + h[73]
        c[3, 4] = -h[14] + h[16] - h[23] - h[26] + h[27] + h[29] + h[31] + h[46] - h[58] + h[76]
        c[4, 4] = h[12] + h[25] + h[26] - h[33] - h[35] - h[40] + h[41] + h[65] - h[68] - h[7]
        c[1, 5] = h[15] + h[24] + h[25] + h[27] - h[28] + h[30] + h[31] - h[4] + h[61] + h[64]
        c[2, 5] = -h[10] - h[18] - h[2] - h[30] - h[38] + h[42] - h[43] + h[46] + h[67] + h[74]
        c[3, 5] = -h[10] + h[12] - h[15] + h[28] + h[29] - h[2] - h[30] - h[3] + h[46] + h[4] - h[75]
        c[4, 5] = -h[12] - h[29] + h[30] - h[34] + h[35] + h[39] + h[3] - h[45] + h[57] + h[59]

        return c

    def ai_multiplication(self, a, b):
        h = self.ai_compute_h(a, b)
        return self.ai_compute_c(h, multiplication=a.multiplication)

    @staticmethod
    def submatrix(a, yrange: tuple[int, int], xrange: tuple[int, int]):
        data = [[a[i, j] for j in range(*xrange)] for i in range(*yrange)]
        return Matrix.in_place(data, a.calculator, a.multiplication)

    @staticmethod
    def _plant(dest, src, offset: tuple[int, int], src_shape: tuple[int, int]):
        for i in range(src_shape[0]):
            for j in range(src_shape[1]):
                dest[i + offset[0]][j + offset[1]] = src[i][j]

    @staticmethod
    def expand(a):
        cy = [0] + list(np.cumsum([a[i, 1].shape[0] for i in range(1, a.shape[0] + 1)]))
        cx = [0] + list(np.cumsum([a[1, i].shape[1] for i in range(1, a.shape[1] + 1)]))
        N = cy[-1]
        M = cx[-1]
        data = [[None] * M for _ in range(N)]

        n, m = a.shape
        for i in range(n):
            for j in range(m):
                offset = (cy[i], cx[j])
                src = a[i + 1, j + 1]
                AIAlgorithm._plant(data, src.data, offset, src.shape)

        return Matrix.in_place(data, a.calculator, a.multiplication)
    def block(self, a, shape: tuple[int, int]):
        assert a.shape[0] >= shape[0] and a.shape[1] >= shape[1], "Matrix too small"

        n, m = a.shape
        y = n // shape[0]
        x = m // shape[1]

        retval = Matrix.empty(*shape, self.calculator, multiplication=a.multiplication)
        for i in range(1, shape[0] + 1):
            for j in range(1, shape[1] + 1):
                yrange = ((i - 1) * y + 1, i * y + 1)
                xrange = ((j - 1) * x + 1, j * x + 1)
                if i == shape[0]:
                    yrange = (yrange[0], n + 1)
                if j == shape[1]:
                    xrange = (xrange[0], m + 1)
                retval[i, j] = self.submatrix(a, yrange, xrange)

        return retval

    def __ai(self, A, B):
        a = Matrix(A, self.calculator, multiplication=self.recursive_ai)
        b = Matrix(B, self.calculator, multiplication=self.recursive_ai)
        return (a @ b).data

    @staticmethod
    def power(a: int, b: int) -> int:
        return b ** math.ceil(math.log(a, b))

    def rescale(self, a, shape):
        data = [[0] * shape[1] for _ in range(shape[0])]

        for i in range(a.shape[0]):
            for j in range(a.shape[1]):
                data[i][j] = a[i + 1, j + 1]

        return Matrix.in_place(data, self.calculator, multiplication=a.multiplication)
    def recursive_ai(self, a, b):
        # Scales up matrices to powers of 4 and 5 by appending zeroes
        if a.shape[0] < 4 or a.shape[1] < 5 or b.shape[0] < 5 or b.shape[1] < 5:
            return Matrix(self.calculator.standard_matrix_multiplication(a.data, b.data), self.calculator, multiplication=a.multiplication)
        n, k = a.shape
        k, m = b.shape
        a = self.rescale(a, shape=(self.power(n, 4), self.power(k, 5)))
        b = self.rescale(b, shape=(self.power(k, 5), self.power(m, 5)))
        a.multiplication = self.recursive_ai_rec
        b.multiplication = self.recursive_ai_rec
        retval = self.recursive_ai_rec(a, b)

        return self.submatrix(retval, yrange=(1, n + 1), xrange=(1, m + 1))

    def recursive_ai_rec(self, a, b):
        # Works only for powers of 4 and 5
        if a.shape[0] < 4 or a.shape[1] < 5 or b.shape[0] < 5 or b.shape[1] < 5:
            return Matrix(self.calculator.standard_matrix_multiplication(a.data, b.data), self.calculator, multiplication=a.multiplication)

        A = self.block(a, shape=(4, 5))
        B = self.block(b, shape=(5, 5))
        return self.expand(self.ai_multiplication(A, B))

    def run(self, A, B):
        self.matrix_3 = self.__ai(A, B)






    def _run_time_test(self, test_info: str, *args):
        print(f"Running {self.algorithm}: {test_info}")
        # time start
        start = timer()
        # run algorithm
        self.algorithm.run(*args)
        # time end
        end = timer()
        time_elapsed = end - start
        print(f"Time: {timedelta(seconds=time_elapsed)}")
        return time_elapsed


    def _extract_calculator_data(self):
        print(f"Atomic additions: {self.algorithm.calculator.add_count}")
        print(f"Atomic subtractions: {self.algorithm.calculator.subtract_count}")
        print(f"Atomic negations: {self.algorithm.calculator.negate_count}")
        print(f"Atomic multiplications: {self.algorithm.calculator.multiply_count}")
        total_count = self.algorithm.calculator.total_count
        self.algorithm.calculator.reset_counters()
        return total_count



class TestBinetAlgorithm(BaseAlgorithmTest):
    def __init__(self):
        super().__init__()
        self.algorithm = BinetAlgorithm()
        self.data = {}
        self.n = 1000

    def run(self):
        range_ = range(800, self.n+1, 100)
        for test_size in range_:
            self.generate_data(test_size)
            time = self._run_time_test(f"{test_size} x {test_size}", self.matrix_1, self.matrix_2)
            flop = self._extract_calculator_data()
            self.data[test_size] = {"time": time,
                                    "flop": flop}
            assert_matrix_multiplication_is_correct(self.matrix_1, self.matrix_2, self.algorithm.matrix_3)

    @classmethod
    def generate_data(cls, test_size):
        cls.matrix_1 = [[0 for _ in range(test_size)] for _ in range(test_size)]
        cls.matrix_2 = [[0 for _ in range(test_size)] for _ in range(test_size)]
        a, b = 0.00000001, 1.0
        for i in range(test_size):
            for j in range(test_size):
                cls.matrix_1[i][j] = uniform(a, b)
                cls.matrix_2[i][j] = uniform(a, b)




class TestStrassenAlgorithm(BaseAlgorithmTest):
    def __init__(self):
        super().__init__()
        self.algorithm = StrassenAlgorithm()
        self.data = {}
        self.n = 1000

    def run(self):
        # range_ = range(300, self.n+1, 50)
        for test_size in [1000]:
            self.generate_data(test_size)
            time = self._run_time_test(f"{test_size} x {test_size}", self.matrix_1, self.matrix_2)
            flop = self._extract_calculator_data()
            self.data[test_size] = {"time": time,
                                    "flop": flop}
            assert_matrix_multiplication_is_correct(self.matrix_1, self.matrix_2, self.algorithm.matrix_3)

    @classmethod
    def generate_data(cls, test_size):
        cls.matrix_1 = [[0 for _ in range(test_size)] for _ in range(test_size)]
        cls.matrix_2 = [[0 for _ in range(test_size)] for _ in range(test_size)]
        a, b = 0.00000001, 1.0
        for i in range(test_size):
            for j in range(test_size):
                cls.matrix_1[i][j] = uniform(a, b)
                cls.matrix_2[i][j] = uniform(a, b)






class TestAIAlgorithm(BaseAlgorithmTest):
    def __init__(self):
        super().__init__()
        self.algorithm = AIAlgorithm()

    def run(self):
        shapes = [
            (4, 5, 5),
            (16, 5, 25),
            (16, 25, 125),
            (13, 29, 63)
        ]

        for shape in shapes:
            self.generate_data(shape)
            self._run_time_test(f"{shape[0]} x {shape[1]}, {shape[1]} x {shape[2]}", self.matrix_1, self.matrix_2)
            self._extract_calculator_data()
            assert_matrix_multiplication_is_correct(self.matrix_1, self.matrix_2, self.algorithm.matrix_3)

    @classmethod
    def generate_data(cls, test_shapes):
        n, k, m = test_shapes
        cls.matrix_1 = [[0 for _ in range(k)] for _ in range(n)]
        cls.matrix_2 = [[0 for _ in range(m)] for _ in range(k)]
        a, b = 0.00000001, 1.0
        for i in range(n):
            for j in range(k):
                cls.matrix_1[i][j] = uniform(a, b)
        for i in range(k):
            for j in range(m):
                cls.matrix_2[i][j] = uniform(a, b)
